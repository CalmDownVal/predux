[x] consider converting store instances to a singleton
[x] try to get rid of the need to wrap things in `dispatch` and `select`
[x] merge thunks and actions
	[x] come up with a way to register both reducer actions and composite actions (thunks) under action UUIDs
	[x] explore possibilities to use @decorators
		[x] `createSlice` only takes the type and initial state (and optionally a display name for debugging)
		[x] `@reducer` takes the slice object and enhances a reducer function to fit the `Dispatchable` interface
		[x] `@selector` takes the slice object and enhances a selector function to select from the correct sub-state
	[x] refine the API to reduce boilerplate as much as possible
[ ] make the connect function smarter
	[ ] don't force update by default, first recalculate props and only then update the component if things changed
	[ ] explore refactoring the connect HOC to a class component to get rid of hooks and hold state with less footprint
	[ ] explore smarter ways of forwarding update notifications to avoid updating children twice (1. because of a parent update, 2. because of a forwarded notification)
	[ ] try to convert connect to a @decorator
[ ] implement support for middleware/enhancer plug-ins
[ ] implement a websocket server to distribute action dispatches between sessions
[ ] implement websocket-enabled middleware to sync stores using the sharing service

Q: TS decorators cannot change the interface of their targets. This limits us a
lot when trying to enhance reducers with remote sync. What would be a good
workaround?

A: The best solution is probably to handle sync within reducers as
fire-and-forget and instead provide a function like `pendingSync()` that can be
awaited to pause execution until sync is done or to catch and handle potential
errors. If sync fails we can rollback the state using a simple transaction.

Q: How do we identify applications? What if there are two apps running at the
same time - their notifications will interfere and cause useless overhead. Same
with sync - how do we know which actions to send where?

A: The notification problem is already solved by placing the `stateChanged`
events into individual stores rather than having a single global event for
everything. There is no way for handlers from one app to bind to events from
another so this is safe by default.

Synchronization is a little trickier, but all we need to sync is reducer calls.
For that simply providing a `SyncStore` class which requires a reference to a
sync client would probably take care of it.
